{"version":3,"sources":["webpack:///./lms/static/completion/js/CompletionOnViewService.js?54b6","webpack:///./lms/static/completion/js/ViewedEvent.js?aa58"],"names":["completedBlocksKeys","Set","markBlocksCompletedOnViewIfNeeded","runtime","containerElement","blockElements","$","find","get","length","tracker","ViewedEventTracker","forEach","blockElement","markCompletedOnViewAfterDelay","parseInt","dataset","addElement","addHandler","event","blockKey","usageId","has","elementHasBeenViewed","ajax","type","url","handlerUrl","data","JSON","stringify","completion","then","add","throttle","fn","wait","time","delay","now","Date","ElementViewing","el","viewedAfterMs","callback","topSeen","bottomSeen","seenForMs","becameVisibleAt","undefined","hasBeenViewed","getBoundingClientRect","setTimeout","checkIfViewed","getTotalTimeSeen","areViewedCriteriaMet","elementViewings","handlers","registerDomHandlers","element","callHandlers","updateVisible","handler","push","elv","rect","getBoundingRect","visible","top","window","innerHeight","markTopSeen","bottom","markBottomSeen","handleVisible","handleNotVisible","onscroll","onresize"],"mappings":"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","file":"CompletionOnViewService.js","sourcesContent":["import { ViewedEventTracker } from './ViewedEvent';\n\nconst completedBlocksKeys = new Set();\n\nexport function markBlocksCompletedOnViewIfNeeded(runtime, containerElement) {\n  const blockElements = $(containerElement).find(\n    '.xblock-student_view[data-mark-completed-on-view-after-delay]',\n  ).get();\n\n  if (blockElements.length > 0) {\n    const tracker = new ViewedEventTracker();\n\n    blockElements.forEach((blockElement) => {\n      const markCompletedOnViewAfterDelay = parseInt(\n        blockElement.dataset.markCompletedOnViewAfterDelay, 10,\n      );\n      if (markCompletedOnViewAfterDelay >= 0) {\n        tracker.addElement(blockElement, markCompletedOnViewAfterDelay);\n      }\n    });\n\n    tracker.addHandler((blockElement, event) => {\n      const blockKey = blockElement.dataset.usageId;\n      if (blockKey && !completedBlocksKeys.has(blockKey)) {\n        if (event.elementHasBeenViewed) {\n          $.ajax({\n            type: 'POST',\n            url: runtime.handlerUrl(blockElement, 'publish_completion'),\n            data: JSON.stringify({\n              completion: 1.0,\n            }),\n          }).then(\n            () => {\n              completedBlocksKeys.add(blockKey);\n              blockElement.dataset.markCompletedOnViewAfterDelay = 0;\n            },\n          );\n        }\n      }\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lms/static/completion/js/CompletionOnViewService.js","/** Ensure that a function is only run once every `wait` milliseconds */\nfunction throttle(fn, wait) {\n  let time = 0;\n  function delay() {\n    // Do not call the function until at least `wait` seconds after the\n    // last time the function was called.\n    const now = Date.now();\n    if (time + wait < now) {\n      time = now;\n      fn();\n    }\n  }\n  return delay;\n}\n\n\nexport class ElementViewing {\n  /**\n   * A wrapper for an HTMLElement that tracks whether the element has been\n   * viewed or not.\n   */\n  constructor(el, viewedAfterMs, callback) {\n    this.el = el;\n    this.viewedAfterMs = viewedAfterMs;\n    this.callback = callback;\n\n    this.topSeen = false;\n    this.bottomSeen = false;\n    this.seenForMs = 0;\n    this.becameVisibleAt = undefined;\n    this.hasBeenViewed = false;\n  }\n\n  getBoundingRect() {\n    return this.el.getBoundingClientRect();\n  }\n\n  /** This element has become visible on screen.\n   *\n   * (may be called even when already on screen though)\n   */\n  handleVisible() {\n    if (!this.becameVisibleAt) {\n      this.becameVisibleAt = Date.now();\n      // We're now visible; after viewedAfterMs, if the top and bottom have been\n      // seen, this block will count as viewed.\n      setTimeout(\n        () => {\n          this.checkIfViewed();\n        },\n        this.viewedAfterMs - this.seenForMs,\n      );\n    }\n  }\n\n  handleNotVisible() {\n    if (this.becameVisibleAt) {\n      this.seenForMs = Date.now() - this.becameVisibleAt;\n    }\n    this.becameVisibleAt = undefined;\n  }\n\n  markTopSeen() {\n    // If this element has been seen for enough time, but the top wasn't visible, it may now be\n    // considered viewed.\n    this.topSeen = true;\n    this.checkIfViewed();\n  }\n\n  markBottomSeen() {\n    this.bottomSeen = true;\n    this.checkIfViewed();\n  }\n\n  getTotalTimeSeen() {\n    if (this.becameVisibleAt) {\n      return this.seenForMs + (Date.now() - this.becameVisibleAt);\n    }\n    return this.seenForMs;\n  }\n\n  areViewedCriteriaMet() {\n    return this.topSeen && this.bottomSeen && (this.getTotalTimeSeen() >= this.viewedAfterMs);\n  }\n\n  checkIfViewed() {\n    // User can provide a \"now\" value for testing purposes.\n    if (this.hasBeenViewed) {\n      return;\n    }\n    if (this.areViewedCriteriaMet()) {\n      this.hasBeenViewed = true;\n      // Report to the tracker that we have been viewed\n      this.callback(this.el, { elementHasBeenViewed: this.hasBeenViewed });\n    }\n  }\n}\n\n\nexport class ViewedEventTracker {\n  /**\n   * When the top or bottom of an element is first viewed, and the entire\n   * element is viewed for a specified amount of time, the callback is called,\n   * passing the element that was viewed, and an event object having the\n   * following field:\n   *\n   * *   hasBeenViewed (bool): true if all the conditions for being\n   *     considered \"viewed\" have been met.\n   */\n  constructor() {\n    this.elementViewings = new Set();\n    this.handlers = [];\n    this.registerDomHandlers();\n  }\n\n  /** Add an element to track.  */\n  addElement(element, viewedAfterMs) {\n    this.elementViewings.add(\n     new ElementViewing(\n       element,\n       viewedAfterMs,\n       (el, event) => this.callHandlers(el, event),\n      ),\n    );\n    this.updateVisible();\n  }\n\n  /** Register a new handler to be called when an element has been viewed.  */\n  addHandler(handler) {\n    this.handlers.push(handler);\n  }\n\n  /** Mark which elements are currently visible.\n   *\n   *  Also marks when an elements top or bottom has been seen.\n   * */\n  updateVisible() {\n    this.elementViewings.forEach((elv) => {\n      if (elv.hasBeenViewed) {\n        return;\n      }\n\n      const now = Date.now(); // Use the same \"now\" for all calculations\n      const rect = elv.getBoundingRect();\n      let visible = false;\n\n      if (rect.top > 0 && rect.top < window.innerHeight) {\n        elv.markTopSeen(now);\n        visible = true;\n      }\n      if (rect.bottom > 0 && rect.bottom < window.innerHeight) {\n        elv.markBottomSeen(now);\n        visible = true;\n      }\n      if (rect.top < 0 && rect.bottom > window.innerHeight) {\n        visible = true;\n      }\n\n      if (visible) {\n        elv.handleVisible(now);\n      } else {\n        elv.handleNotVisible(now);\n      }\n    });\n  }\n\n  registerDomHandlers() {\n    window.onscroll = throttle(() => this.updateVisible(), 100);\n    window.onresize = throttle(() => this.updateVisible(), 100);\n    this.updateVisible();\n  }\n\n  /** Call the handlers for all newly-viewed elements and pause tracking\n   *  for recently disappeared elements.\n   */\n  callHandlers(el, event) {\n    this.handlers.forEach((handler) => {\n      handler(el, event);\n    });\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lms/static/completion/js/ViewedEvent.js"],"sourceRoot":""}